/*

  자연수 A, B (1 ≤ A < B ≤ 1,000,000)가 주어졌을때
  A의 배수 집합과 B의 배수 집합의 합집합의 원소들을 오름차순으로 나열한 수열을 S라 하자

  (S는 당연하게도 무한수열이며 합집합에서 만들어졌으므로 중복된 공배수 역시 수열에 한 번만 나온다.
   예를 들어 A가 6이고 B가 8인 경우 S: 6, 8, 12, 16, 18, 24, 30, 32, ... (공배수인 24도 한번만 나온다)
   와 같이 생겼다.)

  이러한 수열 S의 K (1 ≤ K ≤ 1,000,000)번째 원소를 구하라.

  ##### 입출력 예시

  A: 6,  B: 8, K: 8 => 32

 */
//[2024.04.18]
// 1. A의 배수 배열 만들기.(K번째 까지만 만들기)
// 2. B의 배수 배열 만들기.(K번째 까지만 만들기)
//  2-1. A의 배수 배열 중, 동일 항목 제외 후 합입.
// 3(X). A, B의 배수 배열 합치기.
//  3-1(X). 같은 숫자는 하나만 남긴다.
// 3. A,B 배수 배열 오름차순 정렬.
// 4. 배수 배열에서 index [k-1] 번째 원소 출력.
// 5. Error, 배열이 너무 김.

//[2024.04.19]
// 1. A와 B의 배수의 연속된 배열을 K개 만큼 만들 것임.
//  1-1. A와 B의 배수는 항상 같은 번째의 배수에서 같은 값이 나오지만은 않음.
//  1-2. 따라서, A와 B의 배수 인수는 각각 관리돼야함.
//  1-3. A는 B보다 항상 작으므로, 오름차순으로 정렬되어야 하는 만큼 A의 배수가 배열에 먼저 포함(같을 경우 제외).
//  1-4. (A의 배수 < B의 배수) 일 경우 A배수 포함 후, A의 배수 인수 증가.
// 2. A와 B의 공배수는 한번만 포함 돼야함.
//  2-1. 따라서, (A배수 === B배수)의 경우 둘 중 하나만 배열 포함 및 두 인수 모두 증가.
//  2-2. 나머지 경우 B의 배수 포함.
// 3. 해당 배열의 K번째 숫자를 출력함.
//  3-1. index 번 째의 숫자 호출시 K+1번 째 숫자이므로, [K-1]입력.

export default function kthNumber(A, B, K) {
  // Your code..
  let arr = [];
  let nA = 1;
  let nB = 1;

  do {
    if ( (A * nA) < (B * nB)) {
      arr.push(A * nA);
      nA++;
    } else if ( (A * nA) === (B * nB)) {
      arr.push(A * nA);
      nA++;
      nB++;
    } else {arr.push(B * nB);
      nB++;
    }
  } while (arr.length<=K)
    return arr[K-1];
}
