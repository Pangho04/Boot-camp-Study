# `function`
 - `function` 객체는 함수를 위한 메소드를 제공합니다.   
 - 자바스크립트에서, 모든 함수는 실제로 `function` 객체입니다.   
 - 함수는 프로그램을 구성하는 주요 '구성 요소(building block)'입니다. 함수를 이용하면 중복 없이 유사한 동작을 하는 코드를 여러 번 호출할 수 있습니다.

 ## 함수 선언문
 ```js
function 함수_이름(매개변수, ...) {
   함수 본문;
}
 ```
 - 새롭게 정의한 함수는 함수 이름 옆에 괄호를 붙여서 호출할 수 있다.

```js
function showMessage() {
    alert('Hi!');
}

showMessage();
```
- `showMessage()`로 함수 본문을 호출하면 함수 본문이 실행된다.

## 매개변수
- `매개변수(parameter)`를 이용하면 임의의 데이터를 함수 안에 전달할 수 있다.   
- `매개변수`는 `인자(parameter)`라고 불리기도 한다.
- `매개변수`에 전달되는 값을 `인수(argument)`라고 부르기도 한다.
### 예시
```js
 function showMessage(from, text) {
    alert(from + ': ' + text);
 } // 인자: from, text

 showMessage('Ann', 'Hello!');
 showMessage('Ann', "What's up?");
    //인수(argument)

 //"Ann: Hello!"
 //"Ann: What's up?"
```
## 기본값
- 함수 호출 시 `매개변수`에 인수를 전달하지 않으면, 값은 `undefined`가 된다.
```js
 function showMessage(from, text) {
    alert(from + ': ' + text);
 } // 인자: from, text

 showMessage('Ann', 'Hello!');
 showMessage('Ann', "What's up?");
    //인수(argument)

 //"Ann: Hello!"
 //"Ann: What's up?"
```
- 위의 예시에서 정의한 함수 `showMessage(from, text)`는 매개변수가 2개지만, 다음과 같이 `인수`를 하나만 넣어도 호출할 수 있다.

```js
showMessage("Ann");
//"Ann: undefined"
```
- 이처럼 코드를 작성해도 `error`는 발생하지 않는다. 하지만, 두번째 매개변수에 값을 전달하지 않았기 때문에, `text`엔 `undefined`가 할당된다.   
- `text`가 값을 전달받지 못해도 `undefiend`가 되지 않게 하려면 `기본값(default value)`을 설정해줘야 한다.

```js
fucntion showMessage(from, text = "no text") {
    alert(from + ': " + text);
}

showMessage("Ann");
//"Ann: no text"
```
- 물론 `text`에 해당하는 매개변수가 없을 때만 기본값을 평가한다.

## `return(반환 값)`
- 함수를 호출했을 때, 함수를 호출한 곳에 특정 `반환 값(return value)`이 출력되는 것.
```js
function sum(a, b) {
    return a + b;
}

let result = sum(1, 2);
console.log(result);
// 3

```
- 다음과 같이 `return`만 명시하는 것도 가능하다. 이런 경우, `undefined`값을 반환하며 함수는 즉시 종료된다.
```js
function adult(age) {
    if  (age < 20) {
        return;
    } else {
        console.log("Pass");
    };
}

console.log(adult(19));
// undefiend

```
## 함수 표현식
- 함수를 생성하고 변수에 값을 할당하는 것처럼 생성.   
- 함수 생성 방식과 관계없이 **함수는 값**이며, 따라서 변수에 할당할 수있다.
```js
let 변수이름 = fucntion() {
    함수본문;
}
```
- 함수의 본질은 값이기 때문에, 함수를 복사해 다른 변수에 할당할 수도 있다.
```js
let whoAreU = function() {   // (1) 함수 생성
  console.log( "ken" );
}; // 모든 구문의 끝엔 세미 콜론 ;을 붙이는 게 좋다. 
   // 함수 표현식에 쓰인 세미 콜론은 함수 표현식 때문에 붙여진 게 아니라, 구문의 끝이기 때문에 붙여졌다.

let func = whoAreU;    // (2) 함수 복사

func(); // "ken"     // (3) 복사한 함수를 실행.
whoAreU(); // "ken"    //     본래 함수도 정상적으로 실행.
```

## 콜백 함수
```js
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "동의하십니까?",
  function() { alert("동의하셨습니다."); },
  function() { alert("취소 버튼을 누르셨습니다."); }
); // 함수 showOk와 showCancel이 ask 함수의 인수로 전달됨
```
- 위의 예시처럼 함수를 함수의 인수로 전달하고, 필요하다면 인수로 전달한 `showOk`와 `showCancel`을 나중에 호출(called back)하는 경우, `ask`의 인수, `showOk`와 `showCancel`을 **콜백 함수**또는 **콜백**이라고 부른다.

## 함수 표현식 vs 함수 선언문
1. JaveScript엔진이 언제 함수를 생성하는가.
   - 함수 표현식은 **실제 실행 흐름이 해당 함수에 도달했을 때** 함수를 생성. 따라서 실행 흐름이 함수에 도달했을 때 부터 사용 가능.
```js
sayBye("ken"); // ReferenceError

let sayBye = function(name) {
    console.log( `bye, ${ken}`);
};
```
   - 함수 선언문은 **함수 선언문이 정의되기 전**에도 호출할 수 있다.
```js
sayHi("ken"); // "Hi, Ken"

function sayHi(name) {
    console.log( `hi, ${name}`);
} // 함수 선언문

```
1. 스코프의 차이.
   - 엄격 모드의 경우, 함수 선언문은 코드 블록 내에 어디서든 접근할 수 있다. 하지만, **블록 밖에서는 접근하지 못한다**.

```js
let name = "ken";

if  (name = 'ken') {
    sayHi(); // "Hi, ken"

    function sayHi() {
    console.log( `hi, ${name}`);
    } // 함수 선언문

    sayHi(); // "Hi, Ken"
}

sayHi(); // ReferenceError: sayHi is not defined
```

   - 함수 표현식의 경우, **블록 밖에서도 접근할 수 있다**.
```js
let name = "ken";

let sayBye;

if  (name = 'ken') {

    sayBye = function() {
    console.log( `bye, ${name}`);
    };
}

sayBye(); // "bye, ken"
```