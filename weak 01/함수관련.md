# function
## 정의
* 함수(function)란 하나의 특별한 목적의 작업을 수행하도록 설계된 독립적인 블록을 의미한다.
* 함수는 필요할 때마다 호출하여 해당 작업을 반복해서 수행할 수 있다.
* 자바스크립트에서 모든 함수는 실제로 `Function` 객체이다. `Function` 객체의 프로퍼티와 메소드를 사용할 수 있다. 
* 자바스크립트에서는 함수도 하나의 리터럴이다. 따라서 함수를 변수에 대입하거나, 함수에 프로퍼티를 지정하는 것도 가능하다.
* 자바스크립트 함수는 다른 함수 내에 중첩되어 정의될 수 있다.
* `return` 문을 만나면 함수 실행이 종료된다. 
* `return` 문에 지정한 값이 있을 경우 함수 호출 지점으로 반환하고, 없을 경우 `undefined` 가 반환된다.
* `return` 문 생략 시, 자바스크립트 엔진이 `undefined` 를 대신 반환한다.

<br>

## 함수 선언문
```js
function 함수이름([매개변수1, 매개변수2, ...]) {
  실행문
  ...
  [return 리터럴;]
}
```
* 함수 선언문은 function 키워드로 시작한다.
* 함수 이름을 필수로 선언해야한다.
* 괄호 안에는 매개변수를 정의한다.
* 중괄호 안에는 실행문을 정의한다.
* 호이스팅 때문에 선언과 동시에 대입이 된다.
  ```js
  sayHi(); // 함수 선언문 위에서 함수를 호출해도 오류발생하지 않음 -> 호이스팅

  function sayHi() {
    console.log("good morning! 😎");
  }
  ```

### 매개변수(parameter)와 인수(arguments)
- 함수 `매개변수(parameter)`는 함수 정의 부분에 선언된 이름이다. 이름 그대로 변수이다.
- `매개변수(parameter)`를 이용하면 임의의 데이터를 함수 안에 전달할 수 있다.
- `매개변수(parameter)`에 전달되는 값을 `인수(argument)`라고 부른다.
- `매개변수(parameter)`는 넘겨받은 인수값으로 초기화된다.    
<img src="./parameter.png" style="width:400px">

<br>

### 예시
```js
 function showMessage(from, text) {
    alert(from + ': ' + text);
 } // 인자: from, text

 showMessage('Ann', 'Hello!');
 showMessage('Ann', "What's up?");
    //인수(argument)

 //"Ann: Hello!"
 //"Ann: What's up?"
```
### 기본값
- 함수 호출 시 `매개변수`에 인수를 전달하지 않으면, 값은 `undefined`가 된다.
```js
 function showMessage(from, text) {
    alert(from + ': ' + text);
 } // 인자: from, text

 showMessage('Ann', 'Hello!');
 showMessage('Ann', "What's up?");
    //인수(argument)

 //"Ann: Hello!"
 //"Ann: What's up?"
```
- 위의 예시에서 정의한 함수 `showMessage(from, text)`는 매개변수가 2개지만, 다음과 같이 `인수`를 하나만 넣어도 호출할 수 있다.

```js
showMessage("Ann");
//"Ann: undefined"
```
- 이처럼 코드를 작성해도 `error`는 발생하지 않는다. 하지만, 두번째 매개변수에 값을 전달하지 않았기 때문에, `text`엔 `undefined`가 할당된다.   
- `text`가 값을 전달받지 못해도 `undefiend`가 되지 않게 하려면 `기본값(default value)`을 설정해줘야 한다.

```js
fucntion showMessage(from, text = "no text") {
    alert(from + ': " + text);
}

showMessage("Ann");
//"Ann: no text"
```
- 물론 `text`에 해당하는 매개변수가 없을 때만 기본값을 평가한다.

### `return(반환 값)`
- 함수를 호출했을 때, 함수를 호출한 곳에 특정 `반환 값(return value)`이 출력되는 것.
```js
function sum(a, b) {
    return a + b;
}

let result = sum(1, 2);
console.log(result);
// 3

```
- 다음과 같이 `return`만 명시하는 것도 가능하다. 이런 경우, `undefined`값을 반환하며 함수는 즉시 종료된다.
```js
function adult(age) {
    if  (age < 20) {
        return;
    } else {
        console.log("Pass");
    };
}

console.log(adult(19));
// undefiend

```


## 함수 표현식
```js
const 변수이름 = function [함수이름]([매개변수1, 매개변수2, ...]) {
  함수본문
}
```
* 변수를 선언하고 함수를 대입하는 방식이다.
* 함수 생성 방식과 관계없이 **함수는 값**이며, 따라서 변수에 할당할 수있다.   
* 함수 이름을 생략할 수 있다. (익명함수)
* 호이스팅 되지 않는다.
* 즉시실행함수(IIFE)로 사용될 수 있다.

<br>

```js
let whoAreU = function() {   // (1) 함수 생성
  console.log( "ken" );
}; // 모든 구문의 끝엔 세미 콜론 ;을 붙이는 게 좋다. 
   // 함수 표현식에 쓰인 세미 콜론은 함수 표현식 때문에 붙여진 게 아니라, 구문의 끝이기 때문에 붙여졌다.

let func = whoAreU;    // (2) 함수 복사

func(); // "ken"     // (3) 복사한 함수를 실행.
whoAreU(); // "ken"    //     본래 함수도 정상적으로 실행.
```
- 함수의 본질은 값이기 때문에, 함수를 복사해 다른 변수에 할당할 수도 있다.

## 콜백 함수
```js
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "동의하십니까?",
  function() { alert("동의하셨습니다."); },
  function() { alert("취소 버튼을 누르셨습니다."); }
); // 함수 showOk와 showCancel이 ask 함수의 인수로 전달됨
```
- 위의 예시처럼 함수를 함수의 인수로 전달하고, 필요하다면 인수로 전달한 `showOk`와 `showCancel`을 나중에 호출(called back)하는 경우, `ask`의 인수, `showOk`와 `showCancel`을 **콜백 함수**또는 **콜백**이라고 부른다.

### ❓ 즉시실행함수(IIFE)
```js
(function () {
  console.log("안녕");
})();

(() => {
  // ...
})();

!function () {
  console.log("반가워!");
}();
```
* 정의되자마자 즉시 실행되는 javaScript `Function` 이다.

<br>

📚 번외) 함수이름을 선언할 경우 그 함수의 name 프로퍼티의 값은 함수이름이지만   
익명함수일 경우 함수가 할당되는 변수의 이름이 함수 name 프로퍼티의 값이 된다.
  ```js
  function 함수1() {}
  console.log(함수1.name); // "함수1"

  const 변수1 = function() {}
  console.log(변수1.name); // "변수1"

  const 변수2 = function 함수2() {}
  console.log(변수2.name); // "함수2"
  ```

<br>

## 함수 표현식 vs 함수 선언문
1. JaveScript엔진이 언제 함수를 생성하는가.
    - 함수 표현식은 **실제 실행 흐름이 해당 함수에 도달했을 때** 함수를 생성. 따라서 실행 흐름이 함수에 도달했을 때 부터 사용 가능.
    ```js
    sayBye("ken"); // ReferenceError

    let sayBye = function(name) {
        console.log( `bye, ${ken}`);
    };
    ```
   - 함수 선언문은 **함수 선언문이 정의되기 전**에도 호출할 수 있다.
    ```js
    sayHi("ken"); // "Hi, Ken"

    function sayHi(name) {
        console.log( `hi, ${name}`);
    } // 함수 선언문
    ```
2. 스코프의 차이.
   - 엄격 모드의 경우, 함수 선언문은 코드 블록 내에 어디서든 접근할 수 있다. 하지만, **블록 밖에서는 접근하지 못한다**.

    ```js
    "use strict";

    let name = "ken";

    if  (name = 'ken') {
        sayHi(); // "Hi, ken"

        function sayHi() {
            console.log( `hi, ${name}`);
        } // 함수 선언문

        sayHi(); // "Hi, Ken"
    }

    sayHi(); // ReferenceError: sayHi is not defined
    ```

   - 함수 표현식의 경우, **블록 밖에서도 접근할 수 있다**. (블록 밖에 선언된 변수에 재할당하는 경우)
    ```js
    "use strict";

    let name = "ken";

    let sayBye;

    if  (name = 'ken') {
        sayBye = function() {
            console.log( `bye, ${name}`);
        };
    }

    sayBye(); // "bye, ken"
    ```
<br>

## Function 생성자 함수
```js
const 변수이름 = [new] Function(functionBody)
const 변수이름 = [new] Function(arg1, functionBody)
const 변수이름 = [new] Function(arg1, arg2, functionBody)
const 변수이름 = [new] Function(arg1, arg2, /* …, */ argN, functionBody)
```
* `Function` 생성자는 함수 객체를 생성한다
* 빌트인 함수인 `Function` 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성해 반환한다.
* 생성자를 직접 호출하면 함수를 동적으로 생성할 수 있지만 보안 및 eval()과 유사한(그러나 훨씬 덜 중요한) 성능 문제가 발생한다.
* 그러나 (로컬 스코프에 액세스할 수 있는) eval과 달리 함수 생성자는 전역 스코프에서만 실행되는 함수를 생성한다.
* `Function` 생성자 함수로 생성한 함수는 클로저를 생성하지 않는 등 다른 방식으로 생성한 함수와 다르게 동작한다.


### 예시
```js
const adder = new Function("a", "b", "return a + b");

// Call the function
console.log(adder(2, 6)); // 8
```

```js
new Function("/*", "*/) {");
// SyntaxError: Unexpected end of arg string
// Doesn't become "function anonymous(/*) {*/) {}"
```

## 화살표 함수 () => {}
```js
const 변수이름 = ([매개변수1, 매개변수2, ...]) => { 실행문 }; // 화살표 함수
const 변수이름 = () => { 실행문 };
const 변수이름 = 매개변수 => { 실행문 }; // 매개변수가 하나일 경우 소괄호 생략 가능
```
* 화살표 함수 표현식은 함수 표현식에 대한 간결한 대안이다.
* 기존의 함수보다 표현이 간략하고, 내부 동작 역시 간략화되어 있다.
* 익명함수라고도 한다.
* 생성자 함수로 사용할 수 없다.
* 화살표 함수는 this로 상위 함수의 this를 가져온다. (일반 함수는 this로 전역객체를 갖는다.)
* prototype 프로퍼티가 없고, arguments 객체를 생성하지 않는다.

## 구문

```js
() => 평가식

인수 => 평가식

(인수) => 평가식

(인수1, 인수n) => 평가식

() => {
  수행문
}

인수 => {
  수행문
}

(인수1, 인수2, ... , 인수 n) => {
  수행문
}

() => ({key: value})
```


### 예문

```js
const double = x => x * 2;
console.log(double(4)); // 8 

const arrow = () => { const x = 1 }; // 표현식이 아니라면 중괄호 생략 불가
```
* 실행문이 하나의 표현식이라면 함수 바디를 감싸는 중괄호 `{}` 를 생략할 수 있다.


```js
const obj = (key, value) => ({ [key] : value });
// const obj = (key, value) => { return { [key]: value } }; // 위와 같음

console.log(obj("fruit", ["apple", "grape"]));
// { fruit: [ 'apple', 'grape' ] }
```
* 객체 리터럴을 반환하는 경우 소괄호로 감싸주면 { return }을 생략할 수 있다.

```js
// 기존의 익명 함수
(function (a) {
    return a + 100;
});

(a) => {
    return a + 100;
}

(a) => a + 100;

a => a + 100;

```
- 본문이 여러 줄인 경우 중괄호`{}`안에 평가해야할 코드를 넣어주어야 하며, `return` 문을 사용해 결과값을 반환해야 한다.
- 화살표 함수는 항상 익명이다. (변수에 할당하여 이름 지정)

### 화살표 함수와 일반 함수의 차이
1. 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor이다.
  화살표 함수는 prototype 프로퍼티가 없다.
2. 중복된 매개변수 이름을 생성할 수 없다.
3. 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다.   
-> 상위 스코프를 참조한다.

### 화살표 함수의 this
화살표 함수가 일반 함수와 구별되는 가장 큰 특징은 `this` 이다.   
콜백 함수 내부의 `this` 가 외부 함수의 `this` 와 다르기 때문에 발생하는 문제를 해결하기 위해 의도적으로 설계되었다.

일반 함수의 this는 전역객체 브라우저에서 `window` 이다.   
화살표 함수의 this는 상위 스코프의 this를 가진다. `lexical this` 라 한다.

```js
const obj = {
  name: 'zoey',
  hello: function() {
    console.log(this.name); // 'zoey'
  }
}

obj.hello();

const obj2 = {
  name: 'zoey',
  hello() {

    function hi() { // 일반함수는 this는 전역객체이다.
      console.log(this.name);
      // 브라우저에서 실행 시 window.name 값인 빈 문자열("")
      // Node.js 환경에서는 global에 name 프로퍼티가 없으므로 undefined
    }
    hi();
  }
}

obj2.hello();

const obj3 = {
  name: 'zoey',
  hello() {
    const hi = () => {
      // 화살표 함수의 경우 상위 스코프의 this를 가진다. this-> obj3
      console.log(this.name); 
    };
    hi(); // 'zoey'
  }
}

obj3.hello();
```
<br>

### ES6 메서드 축약 표현
```js
const car = {
  name: 'casper',
  drive: () => console.log(`${this.name}💨💨`) // this-> 전역객체
}
car.drive(); // "💨💨"

const anotherCar = {
  name: 'casper',
  drive() {
    console.log(`${this.name}💨💨`); // this-> anotherCar
  }
}
anotherCar.drive(); // "casper💨💨"
```
* 객체의 메서드를 호출할 경우 화살표 함수의 경우 `this` 가 전역객체이므로,   
ES6 메서드 축약 표현으로 정의한 ES6 메서드를 사용하는 것이 좋다.

<br>

# Rest parameter
## 정의
* 매개변수 이름 앞에 세개의 점 ...을 붙여서 정의한 매개변수이다.
* 함수에 전달된 인수들(arguments)의 목록을 배열로 전달 받는다.
* 함수 호출 시점에 넘길 인수의 개수가 유동적일 때 유용하다.
* 일반 매개변수와 함께 사용할 수 있지만, Rest 파라미터는 가장 뒤에 위치해야한다.
* Rest 파라미터는 단 하나만 선언할 수 있다.
* 매개변수의 개수를 알 수 있는 함수 객체의 length 프로퍼티에 포함되지 않는다.

## 예시
```js
function makeObj(key, ...arr) {
  return {
    [key]: arr
  }
}

const makeObj = (key, ...arr) => ({[key]: arr});

console.log(makeObj("fruit", "🍌", "🍎", "🍇"));
```

```js
function func(...args) {
  console.log(args.length); // 인자의 개수를 알 수 있다.
}

func(); // 0
func(5); // 1
func(5, 6, 7); // 3

console.log(func.length); // 0 함수 객체의 length 프로퍼티에 포함되지 않는다.
```

<br>

## ES6 이전에 사용한 arguments 객체
* `arguments` 객체는 모든 함수 내에서 이용 가능한 지역 변수다.
* 전달된 인수들의 정보를 담고 있는 유사 배열 객체이다.
* 배열 메소드를 사용하기 위해 배열로 변환해야하는 번거로움이 있다.   
👉🏻 ES6에 나온 Rest parameter 사용 권장

  ```js
  function func() {
    console.log(arguments);
  }

  func(1, 2); // [Arguments] { '0': 1, '1': 2, length: 2 }
  ```

<br>

# Default parameter
## 정의
* 함수가 호출될 때 인수 값이 넘어오지 않을 경우 디폴트 매개변수를 사용하면 `undefined` 가 아닌 지정한 값이 매개변수에 할당된다.

## 구문
```js
function 함수이름(매개변수1 = 디폴트값1, /* …, */ 매개변수n = 디폴트값n) {
  // …
}
```

## 예시
```js
function hello(name = "고객") {
  console.log(`${name}님, 반값습니다.`);
}

hello(); // 고객님, 반값습니다.
hello("오지은"); // 오지은님, 반값습니다.
```

