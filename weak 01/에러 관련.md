# `try...catch...finally`
- `try...catch` 수행문은 `try`블록과 `catch`블록이나 `finally`블록, 혹은 둘 다로 이뤄져 있다.

## 구문

```js
try {
    try수행문
} catch (예외문) {
    catch수행문
} finally {
    finally수행문
}
```
- try수행문: 실행될 수행문

- catch수행문: 만약 `try`블록에서 예외가 나올 경우, 실행될 수행문

- 예외문: `catch`블록에서 캐치된 예외를 보관할 부가적인 식별자 혹은 패턴이다. 만약 `catch`블록이 예외값을 사용하지 않는다면, 예외문과 주변 괄호를 생략할 수 있다.

- finally수행문: 제어 흐름이 `try...catch...finally` 구문을 종료하기 전에 실행되는 수행문. 예외가 발생했는지 또는 예외가 잡혔는지 여부와 관계없이 실행됩니다.

## 예문

```js
try {
  nonExistentFunction(); //ReferenceError
} catch (error) {
  console.error(123);
} // '123'
```

## `Catch binding`
- `try`블록에서 예외가 발생하면 예외문(예: `catch(e)`의 경우 e)이 예외값을 보유한다. 이 바인딩을 사용하여 발생한 예외에 대한 정보를 가져올 수 있다. 이 바인딩은 `catch`블록 범위에서만 사용할 수 있다.
- 단일 식별자일 필요는 없으며, 구조 분해 할당을 사용하여 한번에 여러 식별자를 할당할 수 있다.

```js
try {
  throw new TypeError("oops"); // TypeError 객체 생성
} catch ({ name, message }) {
  console.log(name); // "TypeError"
  console.log(message); // "oops"
}
```
- `catch`절에서 생성된 바인딩은 같은 `catch`스코프에 존재하므로, `catch`블록에 선언된 변수는 바인딩과 같은 이름을 가질 수 없다.(예: `name`, `message`)

## `finally`블록
- `finally`블록은 `try`블록과 `catch`블록의 실행된 후에, 실행 될 실행문을 담고 있다.
- 제어 흐름은 항상 다음과 같은 방식 중 한가지로 `finally`블록으로 향한다.
  - `try`블록이 정상적으로 실행된 직후.
  - `catch`블록이 정상적으로 실행된 직후.
  -제어 흐름문( `return`, `throw`, `break`, `continue`)이 `try`블록이나 `catch`블록에서 실행된 직후.
- `catch`블록에서 예외를 처리할 수 없는 경우에도 `try`블록에서가 예외 발생하면, `finally`블록은 여전히 실행된다. 이 경우, `finally`블록이 실행된 직후에도 예외는 여전히 발생한다.

## 예문
```js
function doIt() {
  try {
    return 1;
  } finally { // finally는 try나 catch의 값을 덮어씌움.
    return 2;
  }
}

doIt(); // returns 2
```

- `finally` 블록에서의 제어 흐름 문(statement)들(`return`, `throw`, `break`, `continue`)은 `try` 블록이나 `catch` 블록의 완료 값을 "덮어씌워"버린다. 이 예제에서는 `try` 블록이 1을 반환하려고 시도하지만 반환하기 전에 먼저 `finally` 블록으로 제어 흐름이 넘어가기 때문에, `finally` 블록의 반환 값이 대신 반환됩니다.

## 무조건적인 `catch` 블록
- `catch` 블록을 사용하면 `try` 블록 내에서 예외가 발생할 때 `catch` 블록이 실행됩니다. 아래의 코드에서 예외가 발생하면 제어가 `catch` 블록으로 전달됩니다.

```js
try {
  throw "myException"; // 예외를 발생시킴
} catch (e) {
  // 예외 처리를 위한 문장들
  logMyErrors(e); // 예외 객체를 에러 핸들러에 전달
}
```
## 조건부 `catch`블록
- `try...catch` 블록을 `if...else` `if...else` 구조와 결합하여 "조건부 `catch` 블록"을 만들 수 있다.
```js

try {
  myroutine(); // 세 가지 유형의 예외가 발생할 수 있음
} catch (e) {
  if (e instanceof TypeError) {
    // TypeError 예외를 처리하는 문장들
  } else if (e instanceof RangeError) {
    // RangeError 예외를 처리하는 문장들
  } else if (e instanceof EvalError) {
    // EvalError 예외를 처리하는 문장들
  } else {
    // 지정되지 않은 다른 예외를 처리하는 문장들
    logMyErrors(e); // 예외 객체를 Error handler에 전달
  }
}
```
- 이것은 특정한 예상되는 에러들만 조용히 처리하고, 다른 경우에는 에러를 다시 던지는 일반적인 사용 사례다.


## 중첩된 `try` 블록

```js
try {
  try {
    throw new Error("oops");
  } finally {
    console.log("finally");
  }
} catch (ex) {
  console.error("outer", ex.message);
}

// 출력:
// "finally"
// "outer" "oops"
```
내부 `try` 블록에 `catch` 블록을 추가하여 예외를 처리.

```js
try {
  try {
    throw new Error("oops");
  } catch (ex) {
    console.error("inner", ex.message);
  } finally {
    console.log("finally");
  }
} catch (ex) {
  console.error("outer", ex.message);
}

// 출력:
// "inner" "oops"
// "finally"
```
내부 `catch` 블록에 Error를 재발생.

```js
try {
  try {
    throw new Error("oops");
  } catch (ex) {
    console.error("inner", ex.message);
    throw ex;
  } finally {
    console.log("finally");
  }
} catch (ex) {
  console.error("outer", ex.message);
}

// 출력:
// "inner" "oops"
// "finally"
// "outer" "oops"
```
- 예외를 다시 던지지 않는 한, 가장 가까운  `catch` 블록에서 예외가 한 번만 처리된다. 물론 `catch` 블록 내부에서 새로운 예외가 발생할 경우(예: `catch` 블록에서 예외를 발생시키는 코드 실행), 이는 외부 블록에서 잡힌다.

## `finally` 블록에서의 반환.
- 만약 `finally` 블록에서 반환값이 있는 경우, 이 값은 `try-catch-finally` 문 전체의 반환값이 된다. 이는 `try` 블록이나 `catch` 블록에서의 반환문에 관계없이 적용된다. 이는 `catch` 블록 내에서 발생한 예외에도 적용된다.

```js
(() => {
  try {
    try {
      throw new Error("oops");
    } catch (ex) {
      console.error("inner", ex.message);
      throw ex;
    } finally {
      console.log("finally");
      return;
    }
  } catch (ex) {
    console.error("outer", ex.message);
  }
})();

// 출력:
// "inner" "oops"
// "finally"
```
- `finally` 블록에서의 반환 때문에 바깥 "oops"는 발생하지 않는다. `catch` 블록에서 반환된 값도 동일하게 적용된다.